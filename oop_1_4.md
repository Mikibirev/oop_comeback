# Особенности языка С++
## Содержание
1. Include Gruard
2. Перечисляемый тип
3. Ссылки на функции
4. Статические переменные (static)
5. Строковый тип (string)
6. Преобразование типа (static_cast)
7. Идиома RAII

## Include Gruard в С++
Во избежание ошибок при наложении заголовочных файлов используется **#include guard**, иначе называемая защитой подключения. Данная конструкция состоит из директив **#ifndef** и **#define**:

    #ifndef H_BMW     // Проверка наличия макроса H_BMW, а если его нет
    #define H_BWM     // То определяется макрос и подключается код
    int name() {
        // Исполняемый код...
    }
    #endif  // Граница исполняемого директивой #ifndef кода

Итак, если заголовочный файл был подключён, его повторное подключение не вызовет ошибки. Аналогично **#ifndef** используется **#pragma once**:
    
    #pragma once // Определяется только в начале
    int name() {
        // Исполняемый код...
    }

- [Что такое защита подключения?](https://ru.wikipedia.org/wiki/Include_guard)
- [Что такое макрос?](https://www.opennet.ru/docs/RUS/cpp/cpp-5.html)
- [Для чего нужна директива #ifndef?](http://www.c-cpp.ru/books/ifdef-u-ifndef)
- [Для чего нужна директива #define?](http://www.c-cpp.ru/books/define)

## Перечисляемый тип в C++
Для удобочитаемости кода и визуальной группировки безымянных параметров (цвет, звук, сигнал) используются **перечисляемые типы**. Они задаются ключевым словом **enum**. Например:

    #include <iostream>
    enum Colors {
        COLOR_RED,   // Присваивается значение 0
        COLOR_GREEN, // ... значение 1
        COLOR_BLUE,  // ... значение 2
    };
    int main() {
        Colors tomato = COLOR_RED;       // Красный цвет - 0
        Colors cucumber = COLOR_GREEN;   // Зелёный цвет - 1
        Colors berry = COLOR_BLUE;       // Синий цвет - 2
        std::cout << tomato << endl;       
        return 0;
    }
    
Перечисляемый тип является группировочным аналогом констант и используется для избавления от магических чисел. Перечисляемые типы можно изменять, но нельзя вводить через **std::cin**.
- [Что такое перечисляемый тип?](https://ravesli.com/urok-58-perechisleniya-tip-enum/)
- [Что такое магическое число?](https://ravesli.com/urok-36-literaly-magicheskie-chisla/#toc-3)

## Ссылки на функции в C++ с использованием using
Для удобочитаемости кода используются **using-стейтменты**. Они значительно сокращают время написания кода и его читабельность, однако повышают вероятность ошибок. Обычный вариант:

    #include <iostream>
    int main() {
        std::cout << 450 << endl;
    }

Использование **using-объявления** сокращает конкретную функцию, определённую в пространстве имён, не затрагивая остальные функции. Этот способ не приводит к большим рискам.

    #include <iostream>
    int main() {
        using std::cout;
        cout << 450 << endl;
    }

Для глобального исключения упоминания пространства имён используется **using-директива**. Этот способ значительно упрощает написание и читаемость кода, однако приводит к значительным рискам.

    #include <iostream>
    int main() {
        using namespase std;
        cout << 450 << endl;
    }

Под рисками понимается вероятность совпадения программного идентификатора какой-либо переменной или функции с ключевым словом функции, определяемой библиотекой без пространства имён. Помимо этого **using** используется для упрощения сложных конструкций, например указателя на функцию:

    int foo(int a) {
        return a;
    }
    int main() {
        using uzel = int(*)(int);
        uzel f = foo;
        int b = f(7);
        return b;
    }

- [Что такое пространство имён?](https://ravesli.com/urok-53-prostranstva-imen/)
- [Что такое using-стейтменты?](https://ravesli.com/urok-54-using-statements/)
- [Что такое указатели на функции?](https://ravesli.com/urok-104-ukazateli-na-funktsii/)

## Статические переменные в C++
Ключевое слово **static** ограничивает действие переменной границами программы, если использовано к ней вне блока, и снимает ограничения её действия границами блока, если использовано внутри блока:

    void valuePrint() {
      int value = 0;            // Без ключевого слова static
      ++value;                  // Увеличивается переменная внутри блока
      std::cout << value;       // Выводится одна и та же
    }
 
    int main() {
      valuePrint();            // Вывод - 1
      valuePrint();            // Вывод - 1
      valuedPrint();           // Вывод - 1
    }
    
Использование **static** позволяет правильно организовать идентификаторы:

    void valuePrint() {
      static int s_value = 0;     // C ключевым словом static
      ++s_value;                  // Увеличивается переменная внутри блока
      std::cout << s_value;       // Выводится одна и та же
    }
 
    int main() {
      valuePrint();            // Вывод - 1
      valuePrint();            // Вывод - 2
      valuedPrint();           // Вывод - 3
    }

Несмотря на то, что статические переменные сохраняют своё значение
- [Для чего нужны статические переменные?](https://ravesli.com/urok-51-staticheskie-peremennye/)

## Строковый тип в C++
Строковый тип поддерживается библиотекой **<string>** и пространством имён **std**.

    #include <string>             // Подлючение библиотеки
    std::string name("Misha");    // Присвоение при инициализации
    name = "Misha";               // Присвоение при исполнении
    
Использование **std::cin** не позволяет использовать пробелы в строках. Для этого существует встроенное в библиотеку ключевое слово **std::getline**:

    std::cout << "Введите своё ФИО: ";   // Ввод ФИО в консоль через cin
    std::string name;                    // Создание строки
    std::getline(std::cin, name);        // Изъятие введённого из cin в getline
    
Строки реализуют следующие методы:
1. name.length() - возвращает длину строки беззнаковым типом
2. name.resize(length) - увеличивает или уменьшает длину строки
3. name.clear() - очищает строку
4. name.empty() - возвращает true, если строка пуста, иначе false
5. name.append(number, char) - добавляет в конец строки символы
6. name.erase(pos, cout) - удаляет часть строки
7. name.insert(index, number, char) - вставляет строку в середину строки
8. name.find(string, pos) - ищет вхождение строки в строке 

- [Как использовать строки в C++?](https://ravesli.com/urok-57-vvedenie-v-std-string/)

## Static_cast
Способ явного преобразования типов небезопасен, так как не ограничивает преобразуемые типы. Чтобы преобразовывать типы безопасно, существует **static_cast <выходной тип> (входной тип)**.
- Проверка типа во время выполнения программы не выполняется, что обеспечиает безопасность преобразования типов, однако может привести к непредсказуемым ошибкам.
- **static_cast** можно использовать для проебразования указателя на базовый класс в указатель на производный класс, однако такие операции не всегда безопасны.
- **static_cast** используется для преобразования числовых данных (enums->int, int->float).

Оператор **dynamic_cast** является более безопасным преобразователем, так как, в отличие от static_cast, входные типы данных подвергаются проверке, однако работает только с указателями или ссылками.
Оператор **static_cast** можно использовать для преобразования из типа int в char, однако в результате преобразования в char может не поместиться int. Единственный способ в таком случае - ручной контроль программистом.
- **static_cast** может явно преобразовать целочисленное значение в тип перечисления.
- **static_cast** преобразует нулевое значение указателя в целевой тип null.

## Примеры использования
Пример №0: использование явного преобразования.

    void f() {
        float a = 1.2;
        int b = (int)a;
        // a = 1.2; b = 1;
    }

Пример №1: использование с указателями на объекты класса.

    class B {};
    
    class D : public B {};              // при использовании static_cast с указателями

    void f(B* pb, D* pd) {
        D* pd2 = static_cast<D*>(pb);   // небезопасное преобразование
                                        // D может иметь не входящие в B методы и строки

        B* pb2 = static_cast<B*>(pd);   // безопасное преобразование
                                        // B всегда содержит все методы и строки B
    }

Пример №1: использование с пользовательскими типами данных.

    typedef unsigned char BYTE;

    void f() {                          // преобразование пользовательских типов
        char ch;
        int i = 65;
        float f = 2.5;
        double dbl;

        ch = static_cast<char>(i);      // из int в char
        dbl = static_cast<double>(f);   // из float в double
        i = static_cast<BYTE>(ch);      // из char в пользовательский тип BYTE
    }
    
- [Что такое static_cast?](https://docs.microsoft.com/ru-ru/cpp/cpp/static-cast-operator?view=msvc-170)
- [Что такое dynamic_cast?](https://docs.microsoft.com/ru-ru/cpp/cpp/dynamic-cast-operator?view=msvc-170)
- [Что такое const_cast?](https://docs.microsoft.com/ru-ru/cpp/cpp/const-cast-operator?view=msvc-170)

## RAII
Идиома RAII берёт своё начало в языке C++ и заключается в том, что некоторый ресурс захватывается в конструкторе объекта, и освобождается в его деструкторе. А поскольку деструктор локальных объектов вызывается автоматически при выходе из метода не зависимо от причины, то использование этой идиомы является самым простыми и эффективным способом написания сопровождаемого C++ кода, безопасного с точки зрения исключений.
RAII может использоваться для любых разделяемых объектов или ресурсов:
- для выделения памяти.
- для открытия файлов или устройств.
- для критических секций и мьютексов.

Дополнительно:
- [Что такое мьютекс?](https://ru.wikipedia.org/wiki/Мьютекс)
- [Что такое критическая секция?](https://ru.wikipedia.org/wiki/Критическая_секция)

Важный случай использования RAII - "умные указатели", классы, инкапсулирующие владение памятью. Например, в стандартной библиотеке C++ для этого есть auto_ptr или unique_ptr.

Основной смысл RAII заключается в автоматическом гарантированном освобождении ресурсов, не только при завершении программы и вызове деструктора, но и при выбрасывании исключения. 
Например: ресурсы, создающиеся по ссылке, освобождаются автоматически при покидании зоны видимости, а те, что создаются по указателю, нужно освобождать вручную. При этом в самом объекте должен быть предусмотрен запрет копирования объекта, чтобы данный объект гарантированно являлся единстенным ресурсом в памяти.

Как раз-таки по причине наличия идиомы RAII, C++ не поддерживает **finally** блоков.
## Примеры использования
Пример №1: абстрактное определение.

    Tobj A;                 // ссылка на стек - освобождается автоматически
    Tobj* B = new Tobj;     // выделяется память - освобождать вручную
    
Пример №2: применение RAII для динамической памяти.

    class Stack {
        int *A;
        int A_size;
    public:
        Stack(int _size):A_size(_size) {
           A = new int[_size];
        }
        ~Stack() {
            delete [] A;
        }
        Stack& operator=(const Stack &right) {
            delete [] A;
            A_size = right.A_size;
            A = new int[A_size];
            for(int i = 0; i < A_size; i++)
                A[i] = right.A[i];
        }
    };
    void stack_use() {
        Stack a(50), b(10);
        a = b;
    }
    int main() {
        cout << "Hello world!" << endl;
        stack_use();
        return 0;
    }
    
- [Что такое RAII?(1)](https://www.youtube.com/watch?v=4hZLYpCJZyE&ab_channel=НОУИНТУИТ)
- [Что такое RAII?(2)](https://foxford.ru/wiki/informatika/raii-poluchenie-resursa-est-initsializatsiya)
- [Что такое RAII?(3)](https://ru.wikipedia.org/wiki/Получение_ресурса_есть_инициализация)
- [Почему С++ не поддерживается finally](https://coderoad.ru/161177/Поддерживает-ли-C-блоки-finally-И-что-это-за-RAII-о-котором-я-все-время-слышу)
